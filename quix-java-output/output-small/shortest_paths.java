{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.480035305023193}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.279083251953125}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.270185470581055}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.218763113021851}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.277790307998657}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.248732566833496}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.1815338134765625}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.279550552368164}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.182193279266357}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.125275373458862}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.234323740005493}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) {\n", "entropy": 1.9102675914764404, "length": 256, "finished": false, "message": null, "duration_seconds": 4.243362903594971}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.305768013000488}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.295729875564575}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.253888845443726}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.193698883056641}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.4083781242370605}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.292669773101807}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.235739707946777}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 2.2900497913360596, "length": 256, "finished": false, "message": null, "duration_seconds": 4.282047986984253}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 2.989583969116211, "length": 256, "finished": false, "message": null, "duration_seconds": 4.320502281188965}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 2.989583969116211, "length": 256, "finished": false, "message": null, "duration_seconds": 4.300481557846069}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 2.989583969116211, "length": 256, "finished": false, "message": null, "duration_seconds": 4.311888694763184}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 2.989583969116211, "length": 256, "finished": false, "message": null, "duration_seconds": 4.177732467651367}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.244282007217407}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.22179388999939}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.207645893096924}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.460097551345825}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.207751035690308}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.211491823196411}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.276426553726196}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < INF) {\n", "entropy": 3.1994247436523438, "length": 256, "finished": false, "message": null, "duration_seconds": 4.294041633605957}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                if (update_weight > INF) {\n", "entropy": 3.4311330318450928, "length": 256, "finished": false, "message": null, "duration_seconds": 4.169680833816528}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                if (update_weight > INF) {\n", "entropy": 3.4311330318450928, "length": 256, "finished": false, "message": null, "duration_seconds": 4.376750707626343}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                if (update_weight > INF) {\n", "entropy": 3.4311330318450928, "length": 256, "finished": false, "message": null, "duration_seconds": 4.407651662826538}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > 0) {\n", "entropy": 3.5522050857543945, "length": 256, "finished": false, "message": null, "duration_seconds": 4.2394795417785645}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > 0) {\n", "entropy": 3.5522050857543945, "length": 256, "finished": false, "message": null, "duration_seconds": 4.385160684585571}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > 0) {\n", "entropy": 3.5522050857543945, "length": 256, "finished": false, "message": null, "duration_seconds": 4.234436511993408}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > 0) {\n", "entropy": 3.5522050857543945, "length": 256, "finished": false, "message": null, "duration_seconds": 4.239497423171997}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > 0) {\n", "entropy": 3.5522050857543945, "length": 256, "finished": false, "message": null, "duration_seconds": 4.3358049392700195}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > 0) {\n", "entropy": 3.5522050857543945, "length": 256, "finished": false, "message": null, "duration_seconds": 4.233626842498779}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                \n", "entropy": 4.092199802398682, "length": 256, "finished": false, "message": null, "duration_seconds": 4.2606635093688965}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                \n", "entropy": 4.092199802398682, "length": 256, "finished": false, "message": null, "duration_seconds": 4.313737869262695}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == INF) {\n", "entropy": 4.563305854797363, "length": 256, "finished": false, "message": null, "duration_seconds": 4.193992376327515}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if(update_weight > INF) {\n", "entropy": 5.148155212402344, "length": 256, "finished": false, "message": null, "duration_seconds": 4.2562267780303955}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if(update_weight > INF) {\n", "entropy": 5.148155212402344, "length": 256, "finished": false, "message": null, "duration_seconds": 4.344245910644531}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight <= INF) {\n", "entropy": 5.269916534423828, "length": 256, "finished": false, "message": null, "duration_seconds": 4.266207933425903}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight <= INF) {\n", "entropy": 5.269916534423828, "length": 256, "finished": false, "message": null, "duration_seconds": 4.35177206993103}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 5.66074275970459, "length": 256, "finished": false, "message": null, "duration_seconds": 4.213099002838135}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 5.721993923187256, "length": 256, "finished": false, "message": null, "duration_seconds": 4.241933584213257}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == 0) {\n", "entropy": 5.8072614669799805, "length": 256, "finished": false, "message": null, "duration_seconds": 4.263866424560547}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == 0) {\n", "entropy": 5.8072614669799805, "length": 256, "finished": false, "message": null, "duration_seconds": 4.448897361755371}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int weight = update_weight;\n", "entropy": 6.151477336883545, "length": 256, "finished": false, "message": null, "duration_seconds": 4.145874500274658}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight != INF)\n", "entropy": 6.244416236877441, "length": 256, "finished": false, "message": null, "duration_seconds": 4.466777086257935}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > source.length()) {\n", "entropy": 6.770223617553711, "length": 256, "finished": false, "message": null, "duration_seconds": 4.2984747886657715}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < source.length()) {\n", "entropy": 6.859626770019531, "length": 256, "finished": false, "message": null, "duration_seconds": 4.30152153968811}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight>0) {\n", "entropy": 6.880887985229492, "length": 256, "finished": false, "message": null, "duration_seconds": 4.401375770568848}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight != -1) {\n", "entropy": 7.087450981140137, "length": 256, "finished": false, "message": null, "duration_seconds": 4.170929431915283}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int min_weight = Math.min(\n", "entropy": 7.280077934265137, "length": 256, "finished": false, "message": null, "duration_seconds": 4.108033895492554}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(\n", "entropy": 7.465827465057373, "length": 256, "finished": false, "message": null, "duration_seconds": 4.280993223190308}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight != 0)\n", "entropy": 7.52224063873291, "length": 256, "finished": false, "message": null, "duration_seconds": 4.290462493896484}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.remove(edge);\n", "entropy": 7.673206329345703, "length": 256, "finished": false, "message": null, "duration_seconds": 4.385913133621216}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                int weight = update_weight;\n", "entropy": 7.865115642547607, "length": 256, "finished": false, "message": null, "duration_seconds": 4.335057735443115}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight != 0) weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 8.124007225036621, "length": 256, "finished": false, "message": null, "duration_seconds": 4.288588285446167}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                while (update_weight > INF) {\n", "entropy": 8.297431945800781, "length": 256, "finished": false, "message": null, "duration_seconds": 4.262585163116455}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight>INF) {\n", "entropy": 8.619815826416016, "length": 256, "finished": false, "message": null, "duration_seconds": 4.228266477584839}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) { \n", "entropy": 8.707141876220703, "length": 256, "finished": false, "message": null, "duration_seconds": 4.4757843017578125}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(0))) {\n", "entropy": 8.781045913696289, "length": 256, "finished": false, "message": null, "duration_seconds": 4.402568340301514}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int current_weight = weight_by_node.get(edge);\n", "entropy": 9.073006629943848, "length": 256, "finished": false, "message": null, "duration_seconds": 4.217021465301514}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight>1) {\n", "entropy": 9.855026245117188, "length": 256, "finished": false, "message": null, "duration_seconds": 4.3484156131744385}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                for (int j = update_weight; j > 0; j--) {\n", "entropy": 10.093603134155273, "length": 256, "finished": false, "message": null, "duration_seconds": 4.1421332359313965}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int new_weight = Math.min(update_weight, weight_by_node.get(edge.get(1)));\n", "entropy": 10.893659591674805, "length": 256, "finished": false, "message": null, "duration_seconds": 4.221944570541382}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                int node_weight = INF;\n", "entropy": 11.521483421325684, "length": 256, "finished": false, "message": null, "duration_seconds": 4.453911781311035}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                for (String edge_id : edge) {\n", "entropy": 11.549701690673828, "length": 256, "finished": false, "message": null, "duration_seconds": 4.376920700073242}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF && update_weight <= weight_by_node.get(edge)) {\n", "entropy": 12.064260482788086, "length": 256, "finished": false, "message": null, "duration_seconds": 4.539559602737427}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                for (String edge_1 : edge) {\n", "entropy": 12.370145797729492, "length": 256, "finished": false, "message": null, "duration_seconds": 4.26564359664917}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > (source.length() - 1)) {\n", "entropy": 12.682226181030273, "length": 256, "finished": false, "message": null, "duration_seconds": 4.276221036911011}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > INF) weight_by_node.get(edge.get(1)).add(i);\n", "entropy": 13.232531547546387, "length": 256, "finished": false, "message": null, "duration_seconds": 4.196006774902344}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight >= INF && update_weight < i) {\n", "entropy": 13.478951454162598, "length": 256, "finished": false, "message": null, "duration_seconds": 4.328789472579956}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int cost = update_weight + 1;\n", "entropy": 13.556477546691895, "length": 256, "finished": false, "message": null, "duration_seconds": 4.253978252410889}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight <= inf){\n", "entropy": 13.808813095092773, "length": 256, "finished": false, "message": null, "duration_seconds": 4.261155605316162}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                int accept_weight = Math.min(\n", "entropy": 14.139006614685059, "length": 256, "finished": false, "message": null, "duration_seconds": 4.322698354721069}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int distance = Integer.valueOf(update_weight);\n", "entropy": 14.17296028137207, "length": 256, "finished": false, "message": null, "duration_seconds": 4.142611503601074}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int load_weight = 0;\n", "entropy": 14.345415115356445, "length": 256, "finished": false, "message": null, "duration_seconds": 4.386136770248413}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int insert_weight = weight_by_node.get(edge.get(1)) + 1;\n", "entropy": 14.483335494995117, "length": 256, "finished": false, "message": null, "duration_seconds": 4.399516820907593}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int update_source = weight_by_node.get(edge.get(0))\n", "entropy": 15.107637405395508, "length": 256, "finished": false, "message": null, "duration_seconds": 4.338412761688232}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                int new_node_weight = weight_by_node.get(edge.get(0))\n", "entropy": 15.219204902648926, "length": 256, "finished": false, "message": null, "duration_seconds": 4.187721490859985}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.setValue(edge, update_weight);\n", "entropy": 15.492530822753906, "length": 256, "finished": false, "message": null, "duration_seconds": 4.28821325302124}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < update_weight) update_weight = update_weight \n", "entropy": 16.004722595214844, "length": 256, "finished": false, "message": null, "duration_seconds": 4.263603448867798}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int update_weight_T = Math.min(\n", "entropy": 16.166454315185547, "length": 256, "finished": false, "message": null, "duration_seconds": 4.252856731414795}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if(update_weight - weight_by_edge.get(edge).intValue() < INF){\n", "entropy": 17.550521850585938, "length": 256, "finished": false, "message": null, "duration_seconds": 4.447809934616089}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > MAX_WEIGHT_UPDATE_INTERVAL)\n", "entropy": 18.634647369384766, "length": 256, "finished": false, "message": null, "duration_seconds": 4.270986795425415}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                int num_paths = source.lastIndexOf('/');\n", "entropy": 20.036083221435547, "length": 256, "finished": false, "message": null, "duration_seconds": 4.1951515674591064}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if ((update_weight < INF) || (update_weight > INF + (i - 1))) {\n", "entropy": 20.500885009765625, "length": 256, "finished": false, "message": null, "duration_seconds": 4.187129974365234}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int component = weight_by_edge.get(edge.get(0)).intValue() - update_weight;\n", "entropy": 21.70532989501953, "length": 256, "finished": false, "message": null, "duration_seconds": 4.247883081436157}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                int update_weight_by_node = update_weight / (widthOf(edge) + 1);\n", "entropy": 24.343292236328125, "length": 256, "finished": false, "message": null, "duration_seconds": 4.17106294631958}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                System.out.println(source + \",\" + i + \"|\" + update_weight + \"|\"\n", "entropy": 24.671405792236328, "length": 256, "finished": false, "message": null, "duration_seconds": 4.274617671966553}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (source.startsWith(edge.get(0)) && edge.get(0).length() < source.length()) {\n", "entropy": 25.353490829467773, "length": 256, "finished": false, "message": null, "duration_seconds": 4.252613544464111}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                // Only update the weight if we pass this edge\n", "entropy": 27.227752685546875, "length": 256, "finished": false, "message": null, "duration_seconds": 4.37697172164917}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n                for (int prev_node = 0, next_node = i; prev_node < weight_by_node.get(edge.get(0)) && next_node < weight_by_node.get(edge.get(0)); next_node++) {\n", "entropy": 42.3007698059082, "length": 256, "finished": false, "message": null, "duration_seconds": 4.32762885093689}
