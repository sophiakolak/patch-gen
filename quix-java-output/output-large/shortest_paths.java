{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.8535373210907}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 15.990415811538696}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.230541229248047}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 15.898869514465332}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.86712646484375}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.903827905654907}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.01671075820923}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.131389379501343}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 18.064788818359375}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.42601990699768}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.26473641395569}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.349199533462524}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 15.815829277038574}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.723082304000854}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.023624658584595}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 18.019429683685303}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.231268882751465}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.197624921798706}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.71410322189331}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 16.940542221069336}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 17.602001190185547}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), update_weight);\n", "entropy": 1.5735894441604614, "length": 256, "finished": false, "message": null, "duration_seconds": 15.749068260192871}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 18.234994173049927}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 16.81763458251953}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 16.185827255249023}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 17.131017923355103}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 16.490365505218506}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 18.11408281326294}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 16.328662872314453}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 17.90156650543213}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 18.485136032104492}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 16.6597318649292}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 16.632311582565308}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 17.18243646621704}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 20.27947998046875}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 16.21672296524048}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 17.455669403076172}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight);\n", "entropy": 1.6020681858062744, "length": 256, "finished": false, "message": null, "duration_seconds": 17.751607656478882}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n", "entropy": 2.6699085235595703, "length": 256, "finished": false, "message": null, "duration_seconds": 16.844284057617188}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n", "entropy": 2.6699085235595703, "length": 256, "finished": false, "message": null, "duration_seconds": 15.824938535690308}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n", "entropy": 2.6699085235595703, "length": 256, "finished": false, "message": null, "duration_seconds": 18.20664405822754}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "\n", "entropy": 2.6699085235595703, "length": 256, "finished": false, "message": null, "duration_seconds": 16.22140669822693}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(1))) {\n", "entropy": 3.64638614654541, "length": 256, "finished": false, "message": null, "duration_seconds": 16.573853731155396}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(1))) {\n", "entropy": 3.64638614654541, "length": 256, "finished": false, "message": null, "duration_seconds": 16.203932523727417}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(1))) {\n", "entropy": 3.64638614654541, "length": 256, "finished": false, "message": null, "duration_seconds": 17.61476731300354}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(1))) {\n", "entropy": 3.64638614654541, "length": 256, "finished": false, "message": null, "duration_seconds": 16.39232039451599}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), weight_by_node.get(edge.get(0)) + update_weight);\n", "entropy": 3.6698732376098633, "length": 256, "finished": false, "message": null, "duration_seconds": 16.886637449264526}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > weight_by_node.get(edge.get(1))) {\n", "entropy": 3.8607587814331055, "length": 256, "finished": false, "message": null, "duration_seconds": 16.660800457000732}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > weight_by_node.get(edge.get(1))) {\n", "entropy": 3.8607587814331055, "length": 256, "finished": false, "message": null, "duration_seconds": 16.05544877052307}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > weight_by_node.get(edge.get(1))) {\n", "entropy": 3.8607587814331055, "length": 256, "finished": false, "message": null, "duration_seconds": 16.98306441307068}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), weight_by_node.get(edge.get(0))\n", "entropy": 4.081884384155273, "length": 256, "finished": false, "message": null, "duration_seconds": 19.033175468444824}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), weight_by_node.get(edge.get(0))\n", "entropy": 4.081884384155273, "length": 256, "finished": false, "message": null, "duration_seconds": 16.803525686264038}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), weight_by_node.get(edge.get(0))\n", "entropy": 4.081884384155273, "length": 256, "finished": false, "message": null, "duration_seconds": 16.687371015548706}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1) + edge.get(0), update_weight);\n", "entropy": 4.088665008544922, "length": 256, "finished": false, "message": null, "duration_seconds": 15.930114269256592}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), weight_by_node.get(edge.get(1)) + update_weight);\n", "entropy": 4.14578104019165, "length": 256, "finished": false, "message": null, "duration_seconds": 16.9681396484375}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), weight_by_node.get(edge.get(1)) + update_weight);\n", "entropy": 4.14578104019165, "length": 256, "finished": false, "message": null, "duration_seconds": 16.962090730667114}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), weight_by_node.get(edge.get(1))\n", "entropy": 4.272219657897949, "length": 256, "finished": false, "message": null, "duration_seconds": 16.385541200637817}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                \n", "entropy": 4.358609199523926, "length": 256, "finished": false, "message": null, "duration_seconds": 16.564248085021973}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                \n", "entropy": 4.358609199523926, "length": 256, "finished": false, "message": null, "duration_seconds": 17.03108787536621}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), weight_by_node.get(edge.get(1)) - update_weight);\n", "entropy": 4.392360210418701, "length": 256, "finished": false, "message": null, "duration_seconds": 16.750789165496826}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == weight_by_node.get(edge.get(1))) {\n", "entropy": 4.3932013511657715, "length": 256, "finished": false, "message": null, "duration_seconds": 15.781830072402954}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == weight_by_node.get(edge.get(1))) {\n", "entropy": 4.3932013511657715, "length": 256, "finished": false, "message": null, "duration_seconds": 17.198944807052612}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == weight_by_node.get(edge.get(1))) {\n", "entropy": 4.3932013511657715, "length": 256, "finished": false, "message": null, "duration_seconds": 16.8845055103302}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == weight_by_node.get(edge.get(1))) {\n", "entropy": 4.3932013511657715, "length": 256, "finished": false, "message": null, "duration_seconds": 16.815890312194824}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.min(\n", "entropy": 4.898072719573975, "length": 256, "finished": false, "message": null, "duration_seconds": 18.260082006454468}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.min(\n", "entropy": 4.898072719573975, "length": 256, "finished": false, "message": null, "duration_seconds": 16.557292938232422}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.min(\n", "entropy": 4.898072719573975, "length": 256, "finished": false, "message": null, "duration_seconds": 18.595350980758667}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), Math.max(weight_by_node.get(edge.get(0)), update_weight));\n", "entropy": 5.109766006469727, "length": 256, "finished": false, "message": null, "duration_seconds": 16.26334857940674}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), Math.max(weight_by_node.get(edge.get(0)), update_weight));\n", "entropy": 5.109766006469727, "length": 256, "finished": false, "message": null, "duration_seconds": 18.422770261764526}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), Math.max(weight_by_node.get(edge.get(0)), update_weight));\n", "entropy": 5.109766006469727, "length": 256, "finished": false, "message": null, "duration_seconds": 17.098607063293457}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.min(weight_by_node.get(edge.get(1)), update_weight));\n", "entropy": 5.395002841949463, "length": 256, "finished": false, "message": null, "duration_seconds": 17.279496908187866}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), update_weight + weight_by_node.get(edge.get(0)));\n", "entropy": 5.447331428527832, "length": 256, "finished": false, "message": null, "duration_seconds": 17.354544639587402}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(1)))\n", "entropy": 5.496861457824707, "length": 256, "finished": false, "message": null, "duration_seconds": 16.724666357040405}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), weight_by_node.get(edge.get(0)) - update_weight);\n", "entropy": 5.613956451416016, "length": 256, "finished": false, "message": null, "duration_seconds": 16.66437840461731}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1),\n", "entropy": 5.808599472045898, "length": 256, "finished": false, "message": null, "duration_seconds": 16.844849586486816}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(2))) {\n", "entropy": 5.908575057983398, "length": 256, "finished": false, "message": null, "duration_seconds": 16.79115104675293}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0) + \"-\" + edge.get(1), update_weight);\n", "entropy": 5.928323745727539, "length": 256, "finished": false, "message": null, "duration_seconds": 16.503262519836426}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.min(update_weight, weight_by_node.get(edge.get(1))));\n", "entropy": 6.000176429748535, "length": 256, "finished": false, "message": null, "duration_seconds": 16.459022760391235}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), edge.get(1) + update_weight);\n", "entropy": 6.07936429977417, "length": 256, "finished": false, "message": null, "duration_seconds": 17.764666318893433}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), edge.get(1) + update_weight);\n", "entropy": 6.07936429977417, "length": 256, "finished": false, "message": null, "duration_seconds": 16.784212827682495}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.max(\n", "entropy": 6.136794090270996, "length": 256, "finished": false, "message": null, "duration_seconds": 14.935464859008789}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.max(\n", "entropy": 6.136794090270996, "length": 256, "finished": false, "message": null, "duration_seconds": 16.163750648498535}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1),update_weight);\n", "entropy": 6.248501777648926, "length": 256, "finished": false, "message": null, "duration_seconds": 17.953675746917725}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > weight_by_node.get(edge.get(2))) {\n", "entropy": 6.28612756729126, "length": 256, "finished": false, "message": null, "duration_seconds": 16.26104974746704}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == weight_by_node.get(edge.get(1)))\n", "entropy": 6.496769428253174, "length": 256, "finished": false, "message": null, "duration_seconds": 16.501606702804565}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(1))\n", "entropy": 6.574629783630371, "length": 256, "finished": false, "message": null, "duration_seconds": 16.219992637634277}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == weight_by_node.get(edge.get(0)))\n", "entropy": 6.648476600646973, "length": 256, "finished": false, "message": null, "duration_seconds": 18.25066375732422}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight == weight_by_node.get(edge.get(0)))\n", "entropy": 6.648476600646973, "length": 256, "finished": false, "message": null, "duration_seconds": 16.912599325180054}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(\n", "entropy": 6.707407474517822, "length": 256, "finished": false, "message": null, "duration_seconds": 16.897950410842896}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight > weight_by_node.get(edge.get(1)) + weight_by_node.get(edge.get(0))) {\n", "entropy": 7.632946491241455, "length": 256, "finished": false, "message": null, "duration_seconds": 17.24937915802002}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight < weight_by_node.get(edge.get(0))){\n", "entropy": 8.009791374206543, "length": 256, "finished": false, "message": null, "duration_seconds": 17.562692165374756}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Math.min(weight_by_node.get(edge.get(0)),update_weight));\n", "entropy": 8.524048805236816, "length": 256, "finished": false, "message": null, "duration_seconds": 16.625117778778076}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1) + edge.get(0), \n", "entropy": 9.19115924835205, "length": 256, "finished": false, "message": null, "duration_seconds": 15.98385214805603}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(0), Integer.toString(update_weight));\n", "entropy": 10.05284309387207, "length": 256, "finished": false, "message": null, "duration_seconds": 16.821287393569946}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                while (weight_by_node.get(edge.get(0)) < update_weight) {\n", "entropy": 10.517219543457031, "length": 256, "finished": false, "message": null, "duration_seconds": 16.949416637420654}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                update_weight = Math.max(update_weight,weight_by_node.get(edge.get(1)));\n", "entropy": 11.239603996276855, "length": 256, "finished": false, "message": null, "duration_seconds": 18.579487085342407}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (update_weight - weight_by_node.get(edge.get(1)) < 0) {\n", "entropy": 12.314882278442383, "length": 256, "finished": false, "message": null, "duration_seconds": 16.779781818389893}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                if (weight_by_node.get(edge.get(0) + edge.get(1)) != update_weight) {\n", "entropy": 15.710451126098633, "length": 256, "finished": false, "message": null, "duration_seconds": 17.307931423187256}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                for (String otherEdge : edge) {\n", "entropy": 15.787577629089355, "length": 256, "finished": false, "message": null, "duration_seconds": 16.32828140258789}
{"context": "package java_programs;\nimport java.util.*;\nimport java.lang.Math.*;\n\npublic class SHORTEST_PATHS {\n\n    // Define Infinite as a large enough value. This value will be used\n    // for vertices not connected to each other\n    final static int INF = 99999;\n    \n   \n    public static Map<String, Integer> shortest_paths(String source, Map<List<String>,Integer> weight_by_edge) {\n        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n        for (List<String> edge : weight_by_edge.keySet()) {\n                weight_by_node.put(edge.get(1), INF);\n                weight_by_node.put(edge.get(0), INF);\n        }\n\n        weight_by_node.put(source, 0);\n        for (int i = 0; i < weight_by_node.size(); i++) {\n            for (List<String> edge : weight_by_edge.keySet()) {\n                int update_weight = Math.min(\n                        weight_by_node.get(edge.get(0))\n                                + weight_by_edge.get(edge),\n                        weight_by_node.get(edge.get(1)));\n", "text": "                weight_by_node.put(edge.get(1), get_weight(edge, edge.get(0)) + update_weight);\n", "entropy": 20.85463523864746, "length": 256, "finished": false, "message": null, "duration_seconds": 18.065382480621338}
