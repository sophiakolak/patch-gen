{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5196339818139}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5209322488846999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5212670391408201}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5293633196252999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5304029383972}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.530856681598}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5324737489013}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.533003798497}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5333204832364}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.534588981095}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5366529288882}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5366912126074999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5375230930036999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.53782550614702}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5395623538414}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5400807279418}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5400807279418}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5408783702489199}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5408915491103}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5422617203812001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5433889504522}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5449064670023999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.54518547804}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5465149994316001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5467907157204001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5469909241468001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5478855514179999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5484275626204}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5491679433218001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5491679433218001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5491679433218001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5494607884791}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.54977955371432}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5498093576888}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5526828301053}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5527321563745201}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.555408160054}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5561842645679999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.556195386602}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.557486831428}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5585082438164999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5589564479449999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5589708431655}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5590188549395}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.559060843088}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5596524085169999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.56010012833492}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5604641228739999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5606201150653001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5608819183279999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5608819183279999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5608819183279999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5630066993849}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5632304634005001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5635243187412}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.56765755689622}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.56793187565912}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5692318423955}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5697060820729001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5708837209812999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5713899412312999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5725220408433199}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5795876120582}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5802560342854002}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5810096689684999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5819614127258199}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5836941283549}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5864165748684999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.58718203405332}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5877232236776999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.587945155761}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.5899486131782}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 0.6063903605909999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 2.9979637671297}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 3.0233689500915}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 3.0402678640124003}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(node).addAll(groupByNode.get(vertex_u));", "entropy": 4.325957505013501}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(node).addAll(groupByNode.get(vertex_u));", "entropy": 4.364091878054101}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 3.078813694634}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 3.0875706861310004}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 3.088081867946}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 3.1185866435854}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.put(node, groupByNode.get(vertex_v));", "entropy": 4.544834191505499}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.put(node, groupByNode.get(vertex_v));", "entropy": 4.808695829463498}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (!groupByNode.get(vertex_u).contains(node)) {", "entropy": 5.017489528627318}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode = update(groupByNode, node, vertex_u);", "entropy": 4.298636368154}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (groupByNode.get(vertex_u).contains(node)){", "entropy": 6.898895422111001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_u).add(node);", "entropy": 5.3737859211734005}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (groupByNode.get(vertex_u).contains(node))", "entropy": 7.983538563991999}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(vertex_v).remove(node);", "entropy": 5.7099403852072985}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (groupByNode.get(vertex_v).contains(node)) {", "entropy": 8.541038873839499}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    groupByNode.get(node).add(vertex_u);", "entropy": 6.2913084403645}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    node.setParent(vertex_u);", "entropy": 6.5068113990522}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (node != vertex_u && node != vertex_v) {", "entropy": 6.902562267805001}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (groupByNode.get(vertex_u).contains(node)) {", "entropy": 11.435117678655502}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    node.group = vertex_v.group;", "entropy": 9.244534284086301}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (node != vertex_v && node != vertex_u) {", "entropy": 10.188626954803002}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    Group group = groupByNode.get(vertex_u);", "entropy": 10.637699618210997}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    vertex_u.addChild(node);", "entropy": 7.4128810884}
{"context": "package java_programs;\nimport java.util.*;\npublic class MINIMUM_SPANNING_TREE {\n    public static Set<WeightedEdge> minimum_spanning_tree(List<WeightedEdge> weightedEdges) {\n        Map<Node,Set<Node>> groupByNode = new HashMap<>();\n        Set<WeightedEdge> minSpanningTree = new HashSet<>();\n\n        Collections.sort(weightedEdges);\n\n        for (WeightedEdge edge : weightedEdges) {\n            Node vertex_u = edge.node1;\n            Node vertex_v = edge.node2;\n            //System.out.printf(\"u: %s, v: %s weight: %d\\n\", vertex_u.getValue(), vertex_v.getValue(), edge.weight);\n            if (!groupByNode.containsKey(vertex_u)){\n                groupByNode.put(vertex_u, new HashSet<>(Arrays.asList(vertex_u)));\n            }\n            if (!groupByNode.containsKey(vertex_v)){\n                groupByNode.put(vertex_v, new HashSet<>(Arrays.asList(vertex_v)));\n            }\n\n            if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                minSpanningTree.add(edge);\n                groupByNode = update(groupByNode, vertex_u, vertex_v);\n                for (Node node : groupByNode.get(vertex_v)) {\n", "text": "                    if (node != vertex_v){", "entropy": 7.6017936420789995}
